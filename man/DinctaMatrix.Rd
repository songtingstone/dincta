% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ui.R
\name{DinctaMatrix}
\alias{DinctaMatrix}
\title{Main Dincta interface}
\usage{
DinctaMatrix(
  data_mat,
  meta_data,
  vars_use,
  cell_type_use = NULL,
  R.cross.entropy.type = "bc",
  cell_type_unknown = "unknown",
  Phi_C = NULL,
  do_pca = TRUE,
  npcs = 20,
  theta.batch = NULL,
  alphas = 0.5,
  lambda = NULL,
  sigma.entropy = 0.1,
  sigma.cell_type = 0.1,
  mu = 0.01,
  nclust = NULL,
  n.cell_type.residual = 16,
  k_cluster.n.cells.outer.threshold = 6,
  k_cluster.n.cells.inner.threshold = 1,
  new.cell_type.prob.threshold = 0.8,
  cell_type.sample.fraction = 0.9,
  new.cell_type.main.fraction = 0.6,
  cell_type.eigval.threshold = 0.9,
  cell_type.min.cells = 10,
  new.cell_type.min.cells = 6,
  centroid.cor.threshold = 0.6,
  tau = 0,
  block.size = 0.05,
  min.iter.dincta = 3,
  min.iter.cell_type = 3,
  max.iter.dincta = 20,
  max.iter.cluster = 200,
  frequency.update.Phi_C = NULL,
  refine.Phi_C = FALSE,
  keep.known.cell_type = TRUE,
  max.times.refine.Phi_C = 3,
  select.refine.fraction = 0.2,
  epsilon.cluster = 1e-05,
  epsilon.dincta = 1e-04,
  epsilon.cell_type.changed = 0.01,
  epsilon.cells.type.changed_frequence = 1e-07,
  plot_convergence = FALSE,
  return_object = FALSE,
  reference_values = NULL,
  cluster_prior = NULL,
  verbose = TRUE,
  print.loss = FALSE
)
}
\arguments{
\item{data_mat}{Matrix of normalized gene expession (default) or PCA 
embeddings (see do_pca). 
Cells can be rows or columns.}

\item{meta_data}{Dataframe with variables to integrate.}

\item{vars_use}{The variable(s) in meta_data 
will be removed  batch effects(character vector).}

\item{cell_type_use}{The variable 
contains cell type information (character vector) in meta_data.}

\item{R.cross.entropy.type}{The cross entropy type of clustering loss. Must be 'b' or "bc".
If it is 'b', using the O_kb/E_kb in the cross entropy loss. If it is 'bc', using the O_kcb/E_kcb 
in the cross entropy loss. Default R.cross.entropy.type = 'bc'.}

\item{cell_type_unknown}{The name of the unknown cell type (character), 
Default cell_type_unknow = "unknown".}

\item{Phi_C}{The initial cell type assignment matrix, Optional, can be NULL. If provided, then its dim(Phi_C) ==c(C,N).
Will update the cell type assignment Phi_C[,i] of cell i with meta_data[[cell_type_use]][i] == cell_type_unknown;
and keep the cell type assignments Phi_C[,i] of cells with known cell type,
i.e. meta_data[[cell_type_use]][i] != cell_type_unknown.}

\item{do_pca}{Whether to perform PCA on input matrix.}

\item{npcs}{If doing PCA on input matrix, number of PCs to compute.}

\item{theta.batch}{Diversity clustering penalty parameter. Specify for each
variable in vars_use Default theta.batch=2. theta.batch=0 does not encourage any 
diversity. Larger values of theta result in more diverse clusters.}

\item{alphas}{The scaling factor for unknown cell type cells in each round of Dincta. (float or float vector). 
Between 0 to 1, default 0.5.}

\item{lambda}{Ridge regression penalty parameter. Specify for each variable
 in vars_use. 
Default lambda=1. Lambda must be strictly positive. Smaller values result 
in more aggressive correction.}

\item{sigma.entropy}{Entropy constriant penalty parameter. Default sigma.entropy=0.1.}

\item{sigma.cell_type}{Cell type constraint penalty parameter. Default sigma.cell_type=0.1. 
Larger values of sigma.cell_type result in more strict cell type constraints. 
Suggestion sigma.cell_type <= sigma.entropy.}

\item{mu}{A scalar to control the sparsity in R update, defualt mu = 0.01}

\item{nclust}{Number of clusters in model. nclust=1 equivalent to simple 
linear regression.}

\item{n.cell_type.residual}{The max number of new cell types occurring in the data allowed.}

\item{k_cluster.n.cells.outer.threshold}{The threshold (scalar) which determines the k cluster is the new cluster or not.
when [R(mathcal I) mathbf 1]_k < k_cluster.n.cells.outer.threshold will be regarded as the new cluster.}

\item{k_cluster.n.cells.inner.threshold}{The threshold (scalar) which determines  whether select k cluster to compute the A or not.
when [R mathbf 1]_k > k_cluster.n.cells.inner.threshold will be selected.}

\item{new.cell_type.prob.threshold}{The threshold which determine whether the cells belong to the new cell type or not.
when [sum_{k in mathcal K_{new}} R_ki < new.cell_type.prob.threshold], then the cell i will be regard as the candidate 
cells belong to the new cell type.}

\item{cell_type.sample.fraction}{The fraction of the all cells will be selected as the sample set.}

\item{new.cell_type.main.fraction}{The fraction of the candidate cells belong to the new cell type will be selected as the main set.}

\item{cell_type.eigval.threshold}{The threshold determine the number of the cell types. 
When [lambda(A)(k) < cell_type.eigval.threshold] then $k$ will be count as one cell type.}

\item{cell_type.min.cells}{the min number of  cells that  a cell type should have. If one candiate cell type determined by [lambda(A)(k)]  have the number
the effective cells in the sample set less than cell_type.min.cells, then it will merge to its nearby cell type.}

\item{new.cell_type.min.cells}{the min number of  cells that  a new cell type should have. If one new cell type determined by [lambda(A)(k)]  have the number
the effective cells in the sample set less than new.cell_type.min.cells, then it will merge to its nearby cell type.}

\item{centroid.cor.threshold}{A threshold to determine whether merge two cell type. 
Suppose that Y_c1 is the centroid of the cell type c1,   Y_c2 is the centroid of the cell type c2, if <Y_c1/||Y_c1||,Y_c2/||Y_c2/||> < centroid.cor.threshold; 
then c1 amd c2 will be merged to one cell type.}

\item{tau}{Protection against overclustering small datasets with large ones.
tau is the expected number of cells per cluster.}

\item{block.size}{What proportion of cells to update during clustering.
Between 0 to 1, default 0.05. Larger values may be faster but less accurate}

\item{min.iter.dincta}{Maximum number of rounds of dincta to prevent early convegent of R.  Default min.iter.dincta = 5.}

\item{max.iter.dincta}{Maximum number of rounds to run Dincta. One round
of Dincta involves one clustering and one correction step. Default max.iter.dincta = 10.}

\item{max.iter.cluster}{Maximum number of rounds to run clustering at each 
round of Dincta. Default  max.iter.cluster = 200.}

\item{frequency.update.Phi_C}{Upating Phi_C per frequency.update.Phi_C rounds at clustering.}

\item{refine.Phi_C}{Whether to print refine cell type assignments Phi_C. TRUE to refine}

\item{keep.known.cell_type}{Whether to keep the original known cell type assignment unchanged when refining Phi_C.}

\item{max.times.refine.Phi_C}{The max times to refine Phi_C.It will run dincta iteration until convergent in each time.}

\item{select.refine.fraction}{The fraction of all cells to refine the cell type assignment Phi_C.}

\item{epsilon.cluster}{Convergence tolerance for clustering round of 
Dincta. Set to -Inf to never stop early. Default epsilon.cluster = 1e-5.}

\item{epsilon.dincta}{Convergence tolerance for Dincta. Set to -Inf to
never stop early. Default epsilon.dincta = 1e-4.}

\item{epsilon.cell_type.changed}{The threshold to identify the cell type changed or not. Specifically, 
let Psi_C = Phi_C R^T diag^{-1} (R 1_N) R  be the cell type assignment compute from cluster assignments R, 
if sum(Phi_C[,i] log (Phi_C[,i]/Psi_C[,i]))  > epsilon.cell_type.changed, then cell i will be regarded  as  the cell with unknown cell type.}

\item{epsilon.cells.type.changed_frequence}{Convergence tolerance for refining  cell type assignment matrix Phi_C, 
when the fraction of the number of cells  which have the unknown cell types less 
than the epsilon.cells.type.changed_frequence, stop refining cell type assignment matrix Phi_C.      .}

\item{plot_convergence}{Whether to print the convergence plot of the 
clustering objective function. TRUE to plot, FALSE to suppress. This can be
 useful for debugging.}

\item{return_object}{(Advanced Usage) Whether to return the Dincta object 
or only the corrected PCA embeddings.}

\item{reference_values}{(Advanced Usage) Defines reference dataset(s). 
Cells that have batch variables values matching reference_values will not 
be moved.}

\item{cluster_prior}{(Advanced Usage) Provides user defined clusters for 
cluster initialization. If the number of provided clusters C is less than K, 
Dincta will initialize K-C clusters with kmeans. C cannot exceed K.}

\item{verbose}{Whether to print progress messages. TRUE to print, 
FALSE to suppress.}

\item{print.loss}{Whether to print loss in each step. TRUE to print, 
FALSE to suppress.}
}
\value{
By default, a list consist of the matrix with corrected PCA embeddings, meta_data, and the Phi_C.
The meta_data  contains the predict cell type of the unknown cell type 
and the prob  that the cell belong to the predict cell type.
The Phi_C is the cell type assign matrix
  If return_object 
is TRUE, returns a list consist of the full Dincta object (R6 reference class type) , meta_data and the Phi_C.
The meta_data  and Phi_C are same as described in the default case.
}
\description{
Use this to run the Dincta algorithm on gene expression or PCA matrix.
}
\examples{


## By default, Dincta inputs a normalized gene expression matrix
\dontrun{
dincta_res <- DinctaMatrix(exprs_matrix, meta_data, 'dataset','cell_type')
dincta_embedding <- dincta_res$dincta_embedding
meta_data <- dincta_res$meta_data
Phi_C <- dincta_res$Phi_C
}

## Dincta can also take a PCA embeddings matrix
data(cell_lines)
pca_matrix <- cell_lines$scaled_pcs
meta_data <- cell_lines$meta_data
dincta_res <- DinctaMatrix(pca_matrix, meta_data, 'dataset', 'cell_type', 
                                    do_pca=FALSE)
## dincta_res <- DinctaMatrix(pca_matrix, meta_data, 'dataset', 'partial_unknown_cell_type',  do_pca=FALSE)
                                   
## dincta_res <- DinctaMatrix(pca_matrix, meta_data, 'dataset', 'whole_unknown_cell_type', do_pca=FALSE)
                                    
dincta_embedding <- dincta_res$dincta_embedding
meta_data <- dincta_res$meta_data
Phi_C <- dincta_res$Phi_C                                    

## Output is a matrix of corrected PC embedding and predict cell type in the meta data
dim(dincta_embedding)
dincta_embedding[seq_len(5), seq_len(5)]
head(meta_data)
Phi_C[, seq_len(5)]

## Finally, we can return an object with all the underlying data structures and
## also the  predict cell type in the meta data
dincta_res <- DinctaMatrix(pca_matrix, meta_data, 'dataset', 'cell_type', 
                                    do_pca=FALSE, return_object=TRUE)
## dincta_res <- DinctaMatrix(pca_matrix, meta_data, 'dataset', 'partial_unknown_cell_type',  do_pca=FALSE, return_object=TRUE)
## dincta_res <- DinctaMatrix(pca_matrix, meta_data, 'dataset', 'whole_unknown_cell_type',  do_pca=FALSE, return_object=TRUE)                                
                                    
dincta_object <- dincta_res$dincta_object
meta_data <- dincta_res$meta_data
Phi_C <- dincta_res$Phi_C                                    
dim(dincta_object$Y) ## cluster centroids
dim(dincta_object$R) ## soft cluster assignment
dim(dincta_object$Z_corr) ## corrected PCA embeddings
head(meta_data) ## meta data contains the predict cell type of the unknown cell type  and the prob  that the cell belong to the predict cell type.
Phi_C[, seq_len(5)] ## cell type assign matrix

}
